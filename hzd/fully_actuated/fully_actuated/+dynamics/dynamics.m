function dx = dynamics(t,x,foot_index,Alpha,t_end_of_previous_step,current_stance_foot_position)
    global Fr_overall Fr t_global dq_glb
    
    t_global=[t_global;t+t_end_of_previous_step];
    
    [M,c_vec,B] = dynamics.dynamic_matrix(x,foot_index); % D, c_vec is the expression generated by FROST 
    
    q = x(1:9);
    dq = x(10:18);
    dq_glb = dq;
    if foot_index == -1 % right foot as stance foot
      j_c = numeric_jacobian(@holCtr.right_holonomic_constraint,q);
      dj_c = holCtr.jacDotR(q,dq);
        
    elseif foot_index == 1 % left foot as stance foot
      j_c = numeric_jacobian(@holCtr.left_holonomic_constraint,q);
      dj_c = holCtr.jacDotL(q,dq);
        
    end
    t_i_global = t_global(end);

    inv_m = inv(M);
    
%     B_bar = (B - j_c'*inv(j_c*inv_m*j_c')*j_c*inv_m*B);
%     C_bar = C - (j_c')*inv(j_c*inv_m*j_c')*(j_c*inv_m*c) + j_c'*inv(j_c*inv_m*j_c')*dj_c*dq;
% 

    u = zeros(6,1);
    %u = dynamics.feedback_linearization(t,t_i_global,x,D,c_overall,B_overall,...
    %    foot_index,Alpha,current_stance_foot_position);
     
    B_bar = (B - j_c'*inv(j_c*inv_m*j_c')*j_c*inv_m*B); %the terms that only depend on q and also the part that has the input u
    C_bar = c_vec - (j_c')*inv(j_c*inv_m*j_c')*(j_c*inv_m*c_vec) + (j_c')*inv(j_c*inv_m*j_c')*dj_c; %cbar is the terms that depend on q and q_dot

    my_dq = dq;
    my_ddq = inv_m*(-C_bar + B_bar*u);
    dx= [my_dq ; my_ddq]; %zeros(18,1); %xdot
    
end